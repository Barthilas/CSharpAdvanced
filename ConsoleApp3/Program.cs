using System;
using System.Diagnostics.CodeAnalysis;

namespace ConsoleApp3
{
    interface IBlegh { }
    //type safe equals - IEquatable
    class Vector2 : IBlegh, IEquatable<Vector2>
    {
        public Vector2(float x, float y)
        {
            X = x;
            Y = y;
        }

        public float X { get; set; }
        public float Y { get; set; }

        //Always return the same value, if all values are same in class. Used by hashsets and dictionary...
        public override int GetHashCode()
        {
            //Generated by Resharper.
            unchecked
            {
                return (X.GetHashCode() * 397) ^ Y.GetHashCode();
            }
        }

        //better than operator
        public override bool Equals(object other)
        {
            if (ReferenceEquals(null, other))
                return false;

            if (ReferenceEquals(this, other))
                return true;

            //if (!(obj is Vector2))
            //    return false;

            //var rhs = (Vector2)obj;
            //return X == rhs.X && Y == rhs.Y;

            if (other.GetType() != typeof(Vector2))
                return false;
            return Equals((Vector2)other);
        }

        public bool Equals([AllowNull] Vector2 other)
        {
            if (ReferenceEquals(null, other))
                return false;
            if (ReferenceEquals(this, other))
                return true;

            //most relevant line of equals.
            return X == other.X && Y == other.Y;
        }

        public static bool operator ==(Vector2 lhs, Vector2 rhs)
        {
            return object.Equals(lhs, rhs);
            //Implementation of Equals.
            //if (ReferenceEquals(objA, objB)) or objA == objB
            //    return true;

            //if (objA == null || objB == null)
            //    return false;

            //return objA.X == objB.X && objA.Y == objB.Y;
        }

        public static bool operator !=(Vector2 lhs, Vector2 rhs)
        {
            return !object.Equals(lhs, rhs);
            //return lhs.X != rhs.X || lhs.Y != rhs.Y;
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            var v1 = new Vector2(1, 1);
            var v2 = new Vector2(1, 1);

            //without operators, its false as it compares references.
            //if(v1 == v2)
            //{
            //    Console.WriteLine("EQUALS");
            //}
            //else
            //{
            //    Console.WriteLine("NOT");
            //}

            Compare(v1, v2);
            //Compare(v1, v2);
        }

        static void Compare(IBlegh obj1, IBlegh obj2)
        {
            //if (obj1.Equals(obj2))
            if (object.Equals(obj1, obj2)) // more correct way.
            {
                Console.WriteLine("EQUALS");
            }
            else
            {
                Console.WriteLine("NOT");
            }
        }

        //static void Compare(object obj1, object obj2)
        //{
        //    if (obj1 == obj2)
        //    {
        //        Console.WriteLine("EQUALS");
        //    }
        //    else
        //    {
        //        Console.WriteLine("NOT");
        //    }
        //}

        //static void Compare(IBlegh obj1, IBlegh obj2)
        //{
        //    if (obj1 == obj2)
        //    {
        //        Console.WriteLine("EQUALS");
        //    }
        //    else
        //    {
        //        Console.WriteLine("NOT");
        //    }
        //}

    }
}
